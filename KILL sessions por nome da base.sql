while 1 = 1
waitfor delay '00:01:00'
begin
exec SP_KILL
end
create procedure DBAKILL
as 

--sp_who2

--select * from sysprocesses
--select * from sysdatabases
--/*ESTE SCRIPT MATA AS TODAS AS SESSOÕES CONECTADAS EM UMA DETERMINADA BASE DE DADOS
--  BASTA INFORMAR A BASE DE DADOS NA VARIAVEL @DBNAME*/
--ALTER PROCEDURE SP_KILL AS

--SET NOCOUNT ON

-- 1 - VARIABLE DECLARATION
DECLARE @DBNAME NVARCHAR(32)
DECLARE @DBID INT
DECLARE @CMD1 VARCHAR(8000)
DECLARE @SPIDNUMBER INT
DECLARE @SPIDLISTLOOP INT
DECLARE @SPIDLISTTABLE TABLE
(DBNAME NVARCHAR (32),UIDSPIDLIST INT IDENTITY (1,1),
SPIDNUMBER INT)

SET @DBNAME = 'PRD'

-- 2 - POPULATE @SPIDLISTTABLE WITH THE SPID INFORMATION
INSERT INTO @SPIDLISTTABLE (DBNAME,SPIDNUMBER)
SELECT DISTINCT A.NAME,B.SPID 
FROM sys.databases A INNER JOIN master..sysprocesses B ON (A.database_id = B.dbid)
WHERE B.dbid NOT IN (1,2,3,4) -- MASTER, TEMPDB, MODEL, MSDB
AND B.SPID != 58
AND B.SPID != 56
AND B.SPID != @@SPID
AND B.HostName != 'MARI502'
AND B.HostName != 'M76891'
--AND B.ProgramName Not like 'Carga de estoque Data Warehouse'
AND A.NAME = @DBNAME
ORDER BY SPID DESC

-- 3A - DETERMINE THE HIGHEST UIDSPIDLIST TO LOOP THROUGH THE RECORDS
SELECT @SPIDLISTLOOP = MAX(UIDSPIDLIST) FROM @SPIDLISTTABLE

-- 3B - WHILE CONDITION FOR LOOPING THROUGH THE SPID RECORDS
WHILE @SPIDLISTLOOP > 0
BEGIN

-- 3C - CAPTURE SPIDS LOCATION
SELECT @SPIDNUMBER = SPIDNUMBER
FROM @SPIDLISTTABLE
WHERE UIDSPIDLIST = @SPIDLISTLOOP

-- 3D - STRING TOGETHER THE KILL STATEMENT
SELECT @CMD1 = 'KILL ' + CAST(@SPIDNUMBER AS VARCHAR(5))

-- 3E - EXECUTE THE FINAL STRING TO KILL THE SPIDS
--SELECT @CMD1
EXEC (@CMD1)

-- 3F - DESCEND THROUGH THE SPID LIST
SELECT @SPIDLISTLOOP = @SPIDLISTLOOP - 1
END
SET NOCOUNT OFF
GO


