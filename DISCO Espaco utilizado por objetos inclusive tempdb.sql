SELECT
SUM (user_object_reserved_page_count)*8/1024 as usr_obj_Mb,
SUM (internal_object_reserved_page_count)*8/1024 as internal_obj_Mb,
SUM (version_store_reserved_page_count)*8  as version_store_kb,
SUM (unallocated_extent_page_count)*8/1024 as freespace_Mb,
SUM (mixed_extent_page_count)*8 as mixedextent_kb
FROM sys.dm_db_file_space_usage

/*
You can use the output to learn how tempdb space is being used. The following points will help you analyze the output.

• A higher % allocation for user objects implies that objects that are created by applications (for example, global and local temporary tables and variables) are the major consumers of tempdb. This is not necessarily a cause of concern.
 
• A higher % allocation for internal objects implies that the query plans make heavy use of tempdb. This is not necessarily a problem, but you may want to look at the query plans to see if alternate query plans can be generated by creating indexes or by re-formulating the queries so as to minimize tempdb space usage.
 
• A higher % allocation for the version store implies that version store cleanup cannot keep pace with version generation. See if a long-running transaction is preventing version store cleanup. Or, a high transaction throughput might be generating a large number of versions per minute. The background task cleans up versions every minute. 
 
*/


SELECT top 5 * 
FROM sys.dm_db_session_space_usage  
ORDER BY (user_objects_alloc_page_count +
internal_objects_alloc_page_count) DESC

/*
This DMV tracks the historical allocation/deallocation of pages in tempdb for the 
active sessions. A session is established when a user connects to the database.
The session is active until the connection is terminated. During the course of the session, the user submits one or more batches. This DMV tracks the tempdb space usage only by the completed batches. The following code example shows the top five sessions that have allocated a maximum space for user objects and internal objects in tempdb. This represents the batches that have already completed, but the code lists sessions with heavy tempdb space use. You could look at these first if you want to minimize tempdb consumption. Note that this tempdb space usage does not take into account the impact of this session on the version store space.
*/

SELECT top 5 * 
FROM sys.dm_db_task_space_usage
ORDER BY (user_objects_alloc_page_count +
internal_objects_alloc_page_count) DESC
/*This DMV tracks the allocation/deallocation of tempdb pages by the currently
 executing tasks (also called batches). This is extremely useful when you are 
 running out of space in tempdb. Using this DMV, you can identify tasks with 
 heavy tempdb space use and optionally kill them. 
 You can then analyze why these tasks require heavy tempdb space usage and take corrective action. You can join this DMV with other DMVs to identify the SQL statement and its corresponding query plan for deeper analysis. The following query shows the top five tasks that are currently executing tasks and consuming the most tempdb space. The tempdb space usage returned does not allow for the impact on space consumed by the version store.
*/

SELECT t1.session_id, t1.request_id, t1.task_alloc,
  t1.task_dealloc, t2.sql_handle, t2.statement_start_offset, 
  t2.statement_end_offset, t2.plan_handle
FROM (Select session_id, request_id,
    SUM(internal_objects_alloc_page_count) AS task_alloc,
    SUM (internal_objects_dealloc_page_count) AS task_dealloc 
  FROM sys.dm_db_task_space_usage 
  GROUP BY session_id, request_id) AS t1, 
  sys.dm_exec_requests AS t2
WHERE t1.session_id = t2.session_id
  AND (t1.request_id = t2.request_id)
ORDER BY t1.task_alloc DESC

/*For example you can use the following query that joins the sys.dm_db_task_space_usage and sys.dm_exec_requests DMVs to find the currently active requests*/


--Examine execution plans and see which plans result in more I/O. It is possible that by choosing a better plan (for example, by forcing an index usage for a better query plan), that you can minimize I/O. If there are missing indexes, run Database Engine Tuning Advisor to find the missing indexes. In SQL Server 2005, you can use the following DMV to identify and analyze the queries that are generating the most I/Os. 

SELECT top 10 (total_logical_reads/execution_count),
  (total_logical_writes/execution_count),
  (total_physical_reads/execution_count),
  Execution_count, sql_handle, plan_handle
FROM sys.dm_exec_query_stats  
ORDER BY (total_logical_reads + total_logical_writes) Desc
To get the text of the query, run the following DMV query.

SELECT text 
FROM sys.dm_exec_sql_text (<sql-handle>

--You can examine the query plan by using the following DMV query.

SELECT *
FROM sys.dm_exec_query_plan (<plan_handle>\


